# Controlador Meteorológico Doméstico — Código y estructura

Este documento reúne **todos los archivos de código** para el proyecto: lectura de sensores, almacenamiento, predicción simple, servidor web y visualización en pantalla OLED. Puedes copiar cada archivo a tu Raspberry Pi y seguir las instrucciones de ejecución.

---

## Estructura del proyecto

```
weather-controller/
├── README.md
├── requirements.txt
├── main.py                # Scheduler que recoge datos periódicamente
├── sensors.py             # Lectura de BME280 y MQ-135 (vía MCP3008)
├── db.py                  # Interacción con SQLite (guardar y leer datos)
├── predictor.py           # Lógica de predicción simple
├── display_oled.py        # Mostrar icono en pantalla OLED I2C
├── app.py                 # Servidor Flask + API
├── templates/
│   └── index.html         # Frontend (Chart.js + iconos)
├── static/
│   └── main.js
└── iconos/
    ├── soleado.png
    ├── nublado.png
    └── lluvia.png
```

---

## requirements.txt

```
Flask==2.3.2
Adafruit-BME280==1.3.12
smbus2==0.4.1
spidev==3.5.0
luma.oled==4.2.0
Pillow==10.0.0
schedule==1.1.0
```

---

## README.md (resumen de instalación y ejecución)

```
# Controlador Meteorológico

1. Conecta sensores (BME280 I2C, MCP3008 para MQ-135) a la Raspberry Pi.
2. Instala dependencias: `pip install -r requirements.txt`.
3. Ejecuta `python3 main.py` para iniciar recolección periódica.
4. Ejecuta `python3 app.py` para levantar la web en http://0.0.0.0:5000
```

---

## sensors.py

```python
# sensors.py
# Lectura de BME280 (I2C) y MQ-135 vía MCP3008 (SPI)
import time
from smbus2 import SMBus
import Adafruit_BME280
import spidev

# BME280 (si usas la librería Adafruit)
bme = Adafruit_BME280.BME280(address=0x76)  # cambia a 0x77 si corresponde

# SPI / MCP3008 para MQ-135
spi = spidev.SpiDev()
spi.open(0, 0)
spi.max_speed_hz = 1350000

def read_mcp3008(channel: int) -> int:
    # Channel 0-7
    if channel < 0 or channel > 7:
        return -1
    adc = spi.xfer2([1, (8 + channel) << 4, 0])
    data = ((adc[1] & 3) << 8) + adc[2]
    return data

def read_bme():
    temp = bme.read_temperature()      # Celsius
    press = bme.read_pressure() / 100.0  # hPa
    humid = bme.read_humidity()
    return {"temperature": round(temp, 2), "pressure": round(press, 2), "humidity": round(humid, 2)}

def read_mq135():
    raw = read_mcp3008(0)  # suponer MQ-135 en CH0
    # Convertir raw (0-1023) a voltaje o nivel relativo
    # Se devuelve un valor normalizado 0..1
    return raw / 1023.0

if __name__ == '__main__':
    while True:
        print(read_bme(), "MQ135:", read_mq135())
        time.sleep(5)
```

---

## db.py

```python
# db.py
import sqlite3
from datetime import datetime

DB_PATH = 'weather.db'

def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS readings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts TEXT,
            temperature REAL,
            pressure REAL,
            humidity REAL,
            air_quality REAL
        )
    ''')
    conn.commit()
    conn.close()

def insert_reading(temperature, pressure, humidity, air_quality):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT INTO readings (ts, temperature, pressure, humidity, air_quality) VALUES (?, ?, ?, ?, ?)',
              (datetime.utcnow().isoformat(), temperature, pressure, humidity, air_quality))
    conn.commit()
    conn.close()

def get_last_n_hours(n_hours=24):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT ts, temperature, pressure, humidity, air_quality FROM readings ORDER BY ts DESC LIMIT ?', (n_hours*6,))
    rows = c.fetchall()
    conn.close()
    return rows

def get_latest():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT ts, temperature, pressure, humidity, air_quality FROM readings ORDER BY ts DESC LIMIT 1')
    row = c.fetchone()
    conn.close()
    return row

if __name__ == '__main__':
    init_db()
```

---

## predictor.py

```python
# predictor.py
# Predicción simple: media móvil + regla por presión
import sqlite3
from statistics import mean
from datetime import datetime, timedelta
from db import DB_PATH

def get_recent_values(hours=24):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    since = (datetime.utcnow() - timedelta(hours=hours)).isoformat()
    c.execute('SELECT ts, temperature, pressure FROM readings WHERE ts >= ? ORDER BY ts ASC', (since,))
    rows = c.fetchall()
    conn.close()
    return rows

def predict_temperature_next_day():
    rows = get_recent_values(24)
    if not rows:
        return None
    temps = [r[1] for r in rows]
    # predecir como media de las temperaturas + delta entre últimas 6h y primeras 6h
    avg = mean(temps)
    return round(avg, 2)

def predict_weather_icon():
    rows = get_recent_values(6)  # últimas 6 horas
    if not rows:
        return 'variable'
    presses = [r[2] for r in rows]
    avg_press = mean(presses)
    if avg_press > 1015:
        return 'soleado'
    elif avg_press < 1008:
        return 'lluvia'
    else:
        return 'nublado'

if __name__ == '__main__':
    print('Pred temp:', predict_temperature_next_day())
    print('Icono:', predict_weather_icon())
```

---

## display_oled.py

```python
# display_oled.py
from luma.core.interface.serial import i2c
from luma.oled.device import ssd1306
from PIL import Image
import os

ICON_PATH = 'iconos'

def show_icon(name):
    serial = i2c(port=1, address=0x3C)
    device = ssd1306(serial)
    path = os.path.join(ICON_PATH, f"{name}.png")
    if not os.path.exists(path):
        return False
    img = Image.open(path).convert('1').resize((128, 64))
    device.display(img)
    return True

if __name__ == '__main__':
    show_icon('soleado')
```

---

## main.py (scheduler)

```python
# main.py
import time
import schedule
from sensors import read_bme, read_mq135
from db import init_db, insert_reading
from predictor import predict_weather_icon
from display_oled import show_icon


def job():
    b = read_bme()
    air = read_mq135()
    insert_reading(b['temperature'], b['pressure'], b['humidity'], air)
    icon = predict_weather_icon()
    show_icon(icon)
    print('Guardado:', b, 'AQ:', air, 'Icon:', icon)

if __name__ == '__main__':
    init_db()
    job()  # primer muestreo
    schedule.every(10).minutes.do(job)
    while True:
        schedule.run_pending()
        time.sleep(1)
```

---

## app.py (Flask)

```python
# app.py
from flask import Flask, render_template, jsonify
import sqlite3
from db import DB_PATH
from predictor import predict_temperature_next_day, predict_weather_icon

app = Flask(__name__)

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/api/latest')
def api_latest():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT ts, temperature, pressure, humidity, air_quality FROM readings ORDER BY ts DESC LIMIT 1')
    row = c.fetchone()
    conn.close()
    if not row:
        return jsonify({}), 204
    pred_temp = predict_temperature_next_day()
    pred_icon = predict_weather_icon()
    return jsonify({'ts': row[0], 'temperature': row[1], 'pressure': row[2], 'humidity': row[3], 'air_quality': row[4], 'pred_temp': pred_temp, 'pred_icon': pred_icon})

@app.route('/api/history')
def api_history():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT ts, temperature, pressure FROM readings ORDER BY ts ASC')
    rows = c.fetchall()
    conn.close()
    data = [{'ts': r[0], 'temperature': r[1], 'pressure': r[2]} for r in rows]
    return jsonify(data)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

---

## templates/index.html

```html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Controlador Meteorológico</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Controlador Meteorológico</h1>
  <div>
    <h2>Actual</h2>
    <div id="actual"></div>
    <img id="icono" src="/static/placeholder.png" width="100" />
  </div>

  <canvas id="tempChart" width="400" height="150"></canvas>

  <script src="/static/main.js"></script>
</body>
</html>
```

---

## static/main.js

```javascript
async function refresh(){
  const res = await fetch('/api/latest');
  if(!res.ok) return;
  const data = await res.json();
  document.getElementById('actual').innerText = `Temperatura: ${data.temperature} °C\nPresión: ${data.pressure} hPa\nPredicción mañana: ${data.pred_temp} °C`;
  document.getElementById('icono').src = `/iconos/${data.pred_icon}.png`;
}

setInterval(refresh, 10000);
refresh();
```

---

## iconos

Incluye imágenes para `soleado.png`, `nublado.png`, `lluvia.png` (tamaño 128x64 o similar). Puedes usar iconos libres (por ejemplo, de [Font Awesome] o diseñarlos tú).

---

## Notas y ajustes

* MQ-135 necesita calibración y circuito de acondicionamiento: el valor bruto de MCP3008 se usa aquí como proxy de calidad del aire. Para lecturas reales deberías calibrar usando resistencias y curvas de sensor.
* Si usas un ADC diferente, adapta `sensors.py`.
* Ajusta la lógica de `predictor.py` si quieres usar regresión o modelos ML (ej. scikit-learn) — añadiría variables a `requirements.txt`.

---

Si quieres, ahora puedo:

* Generar cada archivo por separado en el canvas como archivos editables.
* Añadir una versión mejorada del predictor (p. ej. regresión lineal con scikit-learn).
* Preparar una guía de montaje con esquemas de conexión (GPIO / I2C / SPI).

Dime qué prefieres y lo genere en el canvas (archivos listos para copiar).
